# C4 homework

Диаграмма оформлена в формате LikeC4.

Запуск через Docker:

`docker compose up --build`

Открыть диаграмму в браузере: `http://localhost:5173/`

Health-check сервиса: `curl -i http://localhost:8080/health`

## 1) Домены и ответственность

### 1.1 User (Пользователи)
Ответственность:
- профили пользователей (покупатели/продавцы);
- выдача данных покупателя и продавца для заказа.

### 1.2 Catalog (Каталог)
Ответственность:
- карточки товаров;
- категории и атрибуты товаров;
- управление товарами продавца.

### 1.3 Feed (Лента)
Ответственность:
- выдача ленты пользователю;
- запрос рекомендаций в `Recommendation Service`;
- отправка событий поведения польхователя в STQ.

### 1.4 Recommendation (Рекомендации)
Ответственность:
- расчет и выдача рекомендаций  (ml);
- обработка событий из STQ в воркерах (ml);

### 1.5 Order (Заказы)
Ответственност
- оформление и жизненный цикл заказа;
- хранение заказов и статусов;
- запись логов заказов для аналитики.

### 1.6 Payment (Платежи)
Ответственность:
- запуск и обработка платежей;
- интеграция с внешним платежным провайдером (банковские апишки);
- хранение статусов платежей.

### 1.7 Notification (Уведомления)
Ответственность:
- отправка email/SMS/push;
- хранение шаблонов и логов доставки;
- уведомления по событиям заказа и платежа.

### 1.8 Dynamic Config (Динамические конфиги)
Ответственность:
- централизованная выдача runtime-конфигов;
- единая точка для feature flags;
- консистентная конфигурация для всех сервисов.

## 2) Распределение доменов по сервисам

- `API Gateway / BFF` — единая точка входа для `Web/Mobile`, маршрутизация gRPC-вызовов.
- `User Service` — домен User.
- `Catalog Service` — домен Catalog.
- `Feed Service` — домен Feed, но без собственной БД.
- `Recommendation Service` — домен Recommendation (Python + PyTorch/TensorFlow + STQ workers).
- `Order Service` — домен Order.
- `Payment Service` — домен Payment.
- `Notification Service` — домен Notification.
- `Dynamic Config Service` — домен динамических конфигов.

Логика разбиения:
- рекомендательная часть отделена в отдельный Python-сервис, так как использует ML-алгоритмы и свой цикл обновления моделей и прочее млное дело;
- процесс заказа сосредоточен в `Order Service`: он координирует вызовы в `User Service` и `Payment Service`, бизнес-процесс заказа в одном месте - в целом ок для не оч большого маркетплейса;
- `Notification Service` вынесен отдельно, чтобы отправка сообщений была инкапсулирована относительно бизнес-логики + мало ли будет меняться механизм отправки тех же пушей, будем отельно поддерживать это

Обоснование очереди STQ:
- очередь сглаживает спайки нагрузки от событий (`Order`, `Feed`) и защищает сервис  `Recommendation Service` от перегрузки;
- сервисы могут публиковать события быстро, а рекомендер обрабатывает их своим темпом;
- при временной недоступности рекомендера события не теряются, а обрабатываются после восстановления;
- количество воркерв можно масштабировать горизонтально под рост потока событий.

## 3) Границы владения данными и взаимодействия

У каждого сервиса своя БД

Владение данными:
- `User Service` -> `User DB` (users, roles);
- `Catalog Service` -> `Catalog DB` (products, categories, attributes);
- `Order Service` -> `Order DB` (orders, items, statuses);
- `Order Service` -> `Order Analytics DB` (logs всех заказов для аналитики);
- `Payment Service` -> `Payment DB` (payments);
- `Notification Service` -> `Notification DB` (templates, delivery logs);
- `Recommendation Service` -> `Recommendation DB` (features, rankings, profiles);
- `Dynamic Config Service` -> `Config DB` (runtime-конфиги).

Синхронные взаимодействия:
- `Web/Mobile -> API Gateway`;
- `API Gateway -> User/Catalog/Feed/Order` (gRPC);
- `Order -> User` (получение buyer/seller данных);
- `Order -> Payment`;
- `Order -> Notification`;
- `Payment -> Notification`;
- `Feed -> Recommendation`;
- `Все сервисы -> Dynamic Config Service`.

Асинхронные взаимодействия:
- `Order -> STQ` (события заказов);
- `Feed -> STQ` (события поведения).

Синхронная обработка из очереди:
- `STQ -> Recommendation` (gRPC-вызов воркера с подтверждением обработки).

Обоснование походов в сервисы:
- `API Gateway -> доменные сервисы` — единая точка входа и контроль доступа (также рейт лимитер);
- `Order -> User` — заказу нужны buyer/seller данные, но владение остается у `User Service`;
- `Order -> Payment` — оплата привязана к заказу и вызывается в процессе его оформления (bnpl не делаем, хех)
- `Order/Payment -> Notification` — уведомления реализованы отдельным сервисом, чтобы скрыть от основного бизнес процесс их отправки
- `Feed -> Recommendation` — `Feed Service` не имеет свою БД и получает рекомендации из  сервиса рекомендера, выделен отдельно чтобы форматирование ленты было отдельно от ее формирования, также отвечает за курсорную пагинацию и прочее;
- `Все сервисы -> Dynamic Config Service` — единый сервис динамических конфигов, позволяет оперативно отключить некорректнфе фичи или раскатывать жксперименты на польховатиелей

## 4) Реализованный сервис (Docker + health-check)

Реализован сервис: `payment-service` (Python, упрощенный доменный сервис платежей).

Endpoint:
- `GET /health` -> `200 OK` + JSON.

Запуск:
- `docker compose up --build`

Проверка:
- `curl -i http://localhost:8080/health`
- ожидается `HTTP/1.1 200 OK`.
